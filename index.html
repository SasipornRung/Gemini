<!DOCTYPE html>
<html lang="th" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PropDecoded - Data Dashboard</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load D3.js (v7) -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Load Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Custom styles for D3 elements */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* D3 Axis styles for dark mode */
        .axis path,
        .axis line {
            stroke: #4b5563; /* gray-600 */
        }
        .axis text,
        .chart-label {
            fill: #d1d5db; /* gray-300 */
            font-size: 12px;
        }
        .axis .domain {
            stroke-width: 1.5;
        }
        
        /* Chart grid lines */
        .grid-line {
            stroke: #374151; /* gray-700 */
            stroke-opacity: 0.7;
            stroke-dasharray: 2,2;
        }
        
        /* Tooltip style */
        .tooltip {
            position: absolute;
            display: none;
            background-color: rgba(31, 41, 55, 0.9); /* gray-800 bg */
            border: 1px solid #4b5563; /* gray-600 border */
            border-radius: 8px;
            padding: 12px;
            color: #f3f4f6; /* gray-100 text */
            font-size: 13px;
            pointer-events: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: opacity 0.2s;
            z-index: 10;
        }
        
        .tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
        }
        .tooltip-item {
            display: flex;
            justify-content: space-between;
        }
        .tooltip-item span:first-child {
            color: #9ca3af; /* gray-400 */
            margin-right: 8px;
        }
        
        /* Median lines on scatter plot */
        .median-line {
            stroke: #f3f4f6; /* gray-100 */
            stroke-width: 1.5px;
            stroke-dasharray: 4, 4;
            opacity: 0.8;
        }
        .median-label {
            fill: #f3f4f6; /* gray-100 */
            font-size: 10px;
            font-weight: 500;
        }

        /* Toggle button styling */
        .toggle-btn {
            background-color: #374151; /* gray-700 */
            border: 1px solid #4b5563; /* gray-600 */
        }
        .toggle-btn.active {
            background-color: #2563eb; /* blue-600 */
            border-color: #1d4ed8; /* blue-700 */
            color: #ffffff;
        }
        
        /* Sparse data indicator line */
        .sparse-line {
            stroke-dasharray: 3, 3;
            opacity: 0.7;
        }
        /* Sparse data indicator area */
        .sparse-area {
            opacity: 0.1;
            /* A subtle pattern might be better but harder in SVG, opacity is fine */
        }
        
        /* New AI Button Style */
        .ai-btn {
            background-color: #374151; /* gray-700 */
            border: 1px solid #4b5563; /* gray-600 */
            color: #d1d5db; /* gray-300 */
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .ai-btn:hover {
            background-color: #4b5563; /* gray-600 */
            border-color: #6b7280; /* gray-500 */
        }
        
        /* New Event Toggle Button Style */
        .event-toggle-btn {
            background-color: #374151; /* gray-700 */
            border: 1px solid #4b5563; /* gray-600 */
            color: #9ca3af; /* gray-400 */
            padding: 3px 10px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
            opacity: 0.7;
        }
        .event-toggle-btn:hover {
            opacity: 1;
            background-color: #4b5563; /* gray-600 */
        }
        .event-toggle-btn.active {
            opacity: 1;
            color: #ffffff;
            /* Active color will be set by JS */
        }
        
        /* New Modal Style */
        .gemini-modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .gemini-modal-content {
            background-color: #1f2937; /* gray-800 */
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* New CSS Spinner */
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #d1d5db; /* gray-300 */
            border-bottom-color: #3b82f6; /* blue-500 */
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-4 md:p-8">

    <!-- Header -->
    <header class="mb-6">
        <h1 class="text-3xl font-bold text-white">PropDecoded Dashboard</h1>
        <p class="text-lg text-gray-400">Fact-Only Market Analysis</p>
    </header>

    <!-- Main Controls -->
    <div class="mb-6 p-4 bg-gray-800 rounded-lg shadow-md flex flex-col md:flex-row md:items-center gap-4">
        <!-- Area Selector -->
        <div>
            <label for="area-select" class="block text-sm font-medium text-gray-300 mb-1">เลือกพื้นที่ (Area)</label>
            <select id="area-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full md:w-auto p-2.5">
                <!-- Options will be populated by D3 -->
            </select>
        </div>
        
        <!-- Time-Series Toggles -->
        <div class="flex-1">
            <label class="block text-sm font-medium text-gray-300 mb-1">Time-Series Toggles</label>
            <div class="flex flex-wrap gap-2">
                <!-- Nominal/Real Toggle -->
                <div id="price-type-toggle" class="flex rounded-lg">
                    <button data-value="nominal" class="toggle-btn active text-sm font-medium px-4 py-2 rounded-l-lg">Nominal (฿)</button>
                    <button data-value="real" class="toggle-btn text-sm font-medium px-4 py-2 rounded-r-lg">Real (CPI-Adj.)</button>
                </div>
                <!-- Absolute/Index Toggle -->
                <div id="value-type-toggle" class="flex rounded-lg">
                    <button data-value="absolute" class="toggle-btn active text-sm font-medium px-4 py-2 rounded-l-lg">ค่าจริง (฿)</button>
                    <button data-value="index" class="toggle-btn text-sm font-medium px-4 py-2 rounded-r-lg">Index (100)</button>
                </div>
                <!-- Scale Toggle -->
                <div id="scale-type-toggle" class="flex rounded-lg">
                    <button data-value="linear" class="toggle-btn active text-sm font-medium px-4 py-2 rounded-l-lg">Linear Scale</button>
                    <button data-value="log" class="toggle-btn text-sm font-medium px-4 py-2 rounded-r-lg">Log Scale</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Dashboard Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
        
        <!-- A. Time-Series Chart (Full Width) -->
        <div class="lg:col-span-2 p-4 bg-gray-800 rounded-lg shadow-lg">
            <div class="flex justify-between items-center mb-1">
                <h2 id="timeseries-title" class="text-xl font-semibold text-white"></h2>
                <button id="btn-ai-timeseries" class="ai-btn">✨ สรุปข้อมูล (AI)</button>
            </div>
            <p class="text-sm text-gray-400 mb-2">เฉลี่ยประจำปี & ช่วง IQR (fact-only)</p>
            <div id="chart-timeseries-container" class="relative w-full h-[400px] md:h-[450px]">
                <svg id="chart-timeseries" class="w-full h-full"></svg>
            </div>
            <p class="text-xs text-gray-500 mt-2">หมายเหตุ: <span class="border-b border-dashed border-gray-500">เส้นประ/พื้นที่โปร่ง</span> หมายถึงข้อมูลในปีนั้นๆ มีความครอบคลุมต่ำ (low coverage)</p>
        </div>

        <!-- A. Time-Series Chart (Full Width) -->
        <div class="lg:col-span-2 p-4 bg-gray-800 rounded-lg shadow-lg">
            <div class="flex justify-between items-center mb-1">
                <h2 id="timeseries-title" class="text-xl font-semibold text-white"></h2>
                <button id="btn-ai-timeseries" class="ai-btn">✨ สรุปข้อมูล (AI)</button>
            </div>
            <p class="text-sm text-gray-400 mb-2">เฉลี่ยประจำปี & ช่วง IQR (fact-only)</p>
            
            <!-- New Event Toggles -->
            <div id="event-toggles" class="flex flex-wrap gap-2 mb-3">
                <label class="block text-sm font-medium text-gray-300 mr-2 self-center">Event Toggles:</label>
                <!-- Toggles will be populated by D3 -->
            </div>
            
            <div id="chart-timeseries-container" class="relative w-full h-[400px] md:h-[450px]">
                <svg id="chart-timeseries" class="w-full h-full"></svg>
            </div>
            <p class="text-sm text-gray-400 mb-2">แต่ละจุดคือ 1 ยูนิต: ราคา/ตร.ม. × วันที่อยู่ในตลาด (DOM)</p>
            <div id="chart-dom-scatter-container" class="relative w-full h-[400px]">
                <svg id="chart-dom-scatter" class="w-full h-full"></svg>
            </div>
        </div>

        <!-- B2. DOM Distribution -->
        <div class="p-4 bg-gray-800 rounded-lg shadow-lg">
            <h2 id="dom-dist-title" class="text-xl font-semibold text-white mb-1"></h2>
            <p class="text-sm text-gray-400 mb-2">การกระจายตัวของ DOM (แบ่งตาม 5 ปี)</p>
            <div id="chart-dom-dist-container" class="relative w-full h-[400px]">
                <svg id="chart-dom-dist" class="w-full h-full"></svg>
            </div>
        </div>

        <!-- C. Mini-Multiples -->
        <div class="lg:col-span-2 p-4 bg-gray-800 rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold text-white mb-1">Mini-Multiples: เทียบดัชนีราคา (Index=100)</h2>
            <p class="text-sm text-gray-400 mb-4">เปรียบเทียบการเปลี่ยนแปลงราคาเปิดตัว (Launch Price) เทียบกับปี 1995</p>
            <div id="chart-multiples" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
                <!-- Mini charts will be populated by D3 -->
            </div>
        </div>
        
        <!-- D. Future Teaser (Plan Types) -->
        <div class="lg:col-span-2 p-4 bg-gray-800 rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold text-white mb-1">Teaser: สัดส่วน Plan Types (1995-2025)</h2>
            <p class="text-sm text-gray-400 mb-4">แสดงสัดส่วนของยูนิตที่เปิดตัวในแต่ละปี (ข้อมูลจำลอง)</p>
            <div id="chart-plan-types-container" class="relative w-full h-[400px]">
                <svg id="chart-plan-types" class="w-full h-full"></svg>
            </div>
            <p class="text-sm text-gray-500 mt-4 text-center italic">วันนี้คุณเห็น 10% — อีก 90% คือ regression & plan-type timeline</p>
        </div>

    </div>

    <!-- Tooltip Container -->
    <div id="tooltip" class="tooltip"></div>

    <!-- New Gemini AI Modal -->
    <div id="gemini-modal" class="gemini-modal-overlay hidden">
        <div class="gemini-modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 id="gemini-modal-title" class="text-lg font-semibold text-white"></h3>
                <button id="gemini-modal-close" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <!-- Loading State -->
            <div id="gemini-modal-loading" class="text-center">
                <div class="loader"></div>
                <p class="text-gray-300">กำลังประมวลผล... กรุณารอสักครู่</p>
            </div>
            
            <!-- Result State -->
            <div id="gemini-modal-result" class="hidden">
                <div id="gemini-modal-text" class="prose prose-invert max-w-none text-gray-200 whitespace-pre-wrap"></div>
            </div>
            
            <button id="gemini-modal-close-btn" class="mt-6 w-full toggle-btn active py-2">ปิด</button>
        </div>
    </div>

    <script type="module">
        // === 0. GEMINI API CONFIG ===
        const apiKey = ""; // Leave as-is, Canvas will inject the key
        const apiUrl = `https://generativelace.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        /**
         * Calls the Gemini API with exponential backoff.
         * @param {string} systemPrompt - The system instruction for the AI.
         * @param {string} userPrompt - The user query (e.g., JSON data).
         * @param {number} maxRetries - Maximum number of retries.
         * @returns {Promise<Object>} - The JSON response from the API.
         */
        async function callGeminiAPI(systemPrompt, userPrompt, maxRetries = 3) {
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            let delay = 1000; // 1 second
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        return { text: candidate.content.parts[0].text };
                    } else {
                        throw new Error("Invalid API response structure.");
                    }

                } catch (error) {
                    if (i === maxRetries - 1) {
                        // Last retry failed
                        throw error;
                    }
                    // Wait for exponential backoff delay (don't log as error)
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Double the delay
                }
            }
        }
        
        // === 1. MOCK DATA GENERATION ===
        // Based on the provided schema

        const areas = [
            { area_id: 'A01', area_name: 'New CBD (Rama 9)', area_group: 'CBD' },
            { area_id: 'A02', area_name: 'Sukhumvit (Early)', area_group: 'CBD' },
            { area_id: 'A03', area_name: 'Riverside (Charoen.)', area_group: 'Luxury' },
            { area_id: 'A04', area_name: 'Ladprao', area_group: 'Midtown' }
        ];

        const events = [
            { year: 1997, label: 'วิกฤตต้มยำกุ้ง', type: 'policy' },
            { year: 2003, label: 'รถไฟฟ้า BTS เปิด', type: 'transit' },
            { year: 2008, label: 'ผังเมืองใหม่ (Orange)', type: 'plan' },
            { year: 2011, label: 'มหาอุทกภัย', type: 'landmark' },
            { year: 2017, label: 'รถไฟฟ้าสายสีส้ม (เริ่ม)', type: 'transit' },
            { year: 2020, label: 'COVID-19', type: 'landmark' },
            { year: 2022, label: 'ผ่อนคลาย LTV', type: 'policy' }
        ];
        
        const cpiData = {};
        let cpi = 70;
        for (let y = 1995; y <= 2025; y++) {
            cpiData[y] = cpi;
            cpi += (Math.random() * 2 + 1); // CPI growth
        }
        cpiData[2025] = cpi; // Use last value for 2025

        const prices_yearly = [];
        const basePrices = { 'A01': 60000, 'A02': 75000, 'A03': 80000, 'A04': 45000 };
        const growthRates = { 'A01': 1.07, 'A02': 1.065, 'A03': 1.06, 'A04': 1.075 };

        areas.forEach(area => {
            let currentPrice = basePrices[area.area_id];
            for (let year = 1995; year <= 2025; year++) {
                let noise = 1 + (Math.random() - 0.5) * 0.1; // 10% noise
                let launch_price_avg = currentPrice * noise;
                
                // Simulate 1997 crisis dip
                if (year >= 1997 && year <= 2000) {
                    launch_price_avg *= (0.7 + (year - 1997) * 0.05);
                }
                
                // Simulate resale price (lags launch)
                let resale_price_avg = prices_yearly.length > 2 
                    ? prices_yearly[prices_yearly.length - 2].launch_price_avg * (1 + (Math.random() - 0.4) * 0.1)
                    : launch_price_avg * 0.9;
                
                prices_yearly.push({
                    area_id: area.area_id,
                    year: year,
                    launch_price_avg: launch_price_avg,
                    launch_price_p25: launch_price_avg * (0.9 - Math.random() * 0.05),
                    launch_price_p75: launch_price_avg * (1.1 + Math.random() * 0.05),
                    resale_price_avg: resale_price_avg,
                    cpi_index: cpiData[year],
                    coverage_flag: (year < 2000) ? 'low' : 'high' // Mark early years as low coverage
                });
                
                currentPrice *= (growthRates[area.area_id] * (1 + (Math.random() - 0.5) * 0.02));
            }
        });

        const listings = [];
        areas.forEach(area => {
            let areaAvgPrice = prices_yearly.find(p => p.area_id === area.area_id && p.year === 2024).launch_price_avg;
            for (let i = 0; i < 150; i++) {
                let price_sqm = areaAvgPrice * (1 + (Math.random() - 0.5) * 0.6); // Wide variance
                let dom_days = Math.floor(Math.pow(Math.random(), -0.3) * 30 + (price_sqm / areaAvgPrice * 50));
                if (dom_days > 730) dom_days = 730 + Math.random() * 100;
                if (dom_days < 5) dom_days = 5 + Math.random() * 5;
                
                listings.push({
                    listing_id: `L-${area.area_id}-${i}`,
                    area_id: area.area_id,
                    price_sqm: price_sqm,
                    dom_days: dom_days,
                    project: `Project #${i % 10}`,
                    size_sqm: 30 + Math.random() * 20,
                    plan_type: (Math.random() > 0.6) ? '1Bed' : '1Bed+',
                });
            }
        });

        const dom_stats = [];
        const yearBuckets = ['2000-2004', '2005-2009', '2010-2014', '2015-2019', '2020-2024'];
        areas.forEach(area => {
            let baseDom = 150 - (area.area_id.charCodeAt(2) * 20);
            yearBuckets.forEach(bucket => {
                let dom_median = (baseDom * (1 - (yearBuckets.indexOf(bucket) * 0.1))) * (1 + (Math.random() - 0.5) * 0.2);
                dom_stats.push({
                    area_id: area.area_id,
                    year_bucket: bucket,
                    dom_median: dom_median,
                    dom_p25: dom_median * 0.6,
                    dom_p75: dom_median * 1.8,
                    n_listings: 100 + Math.random() * 50
                });
            });
        });
        
        const plan_types_data = [];
        let shares = { '1Bed': 0.4, '1Bed+': 0.1, '2Bed': 0.4, 'Lite': 0.1 };
        for (let year = 1995; year <= 2025; year++) {
            shares['1Bed'] += (Math.random() - 0.45) * 0.05;
            shares['2Bed'] -= (Math.random() - 0.4) * 0.05;
            shares['1Bed+'] += (Math.random() - 0.3) * 0.03;
            shares['Lite'] += (Math.random() - 0.3) * 0.02;
            
            // Normalize
            let total = Object.values(shares).reduce((a, b) => a + b, 0);
            let normalized = { year: new Date(year, 0, 1) };
            Object.keys(shares).forEach(k => {
                shares[k] = Math.max(0.05, shares[k]); // floor
                normalized[k] = shares[k] / total;
            });
            total = Object.values(normalized).slice(1).reduce((a, b) => a + b, 0); // re-normalize after floor
             Object.keys(shares).forEach(k => {
                normalized[k] = normalized[k] / total;
            });
            plan_types_data.push(normalized);
        }

        // === 2. GLOBAL STATE ===
        let state = {
            currentAreaId: 'A01',
            priceType: 'nominal', // nominal vs real
            valueType: 'absolute', // absolute vs index
            scaleType: 'linear', // linear vs log
            activeEventTypes: ['transit', 'policy', 'landmark'] // Default active types
        };
        
        const d3_colors = {
            launch: '#2dd4bf', // teal-400
            resale: '#60a5fa', // blue-400
            iqrLaunch: '#14b8a6', // teal-500
            iqrResale: '#3b82f6', // blue-500
        };
        
        // New Event Type Colors
        const event_colors = {
            transit: '#f59e0b', // amber-500
            policy: '#ec4899', // pink-500
            plan: '#84cc16', // lime-500
            landmark: '#8b5cf6', // violet-500
        };

        // === 3. D3 CHARTING FUNCTIONS ===
        const margin = { top: 30, right: 50, bottom: 50, left: 70 };
        const tooltip = d3.select("#tooltip");
        const priceFormatter = d3.format(",.0f");
        const domFormatter = d3.format(".0f");
        const indexFormatter = d3.format(".0f");

        // --- Chart A: Time-Series ---
        let ts = {}; // Time-Series chart object
        function initTimeSeriesChart() {
            const container = d3.select("#chart-timeseries-container");
            const svg = d3.select("#chart-timeseries");
            svg.selectAll("*").remove(); // Clear previous
            
            const { width, height } = container.node().getBoundingClientRect();
            const w = width - margin.left - margin.right;
            const h = height - margin.top - margin.bottom;

            ts.svg = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Scales
            ts.x = d3.scaleTime().range([0, w]);
            ts.y = d3.scaleLinear().range([h, 0]); // Placeholder, will be updated

            // Axes
            ts.xAxisGroup = ts.svg.append("g")
                .attr("class", "axis axis-x")
                .attr("transform", `translate(0,${h})`);
            ts.yAxisGroup = ts.svg.append("g")
                .attr("class", "axis axis-y");
                
            // Y-Axis Grid
            ts.yGrid = ts.svg.append("g")
                .attr("class", "grid-line");

            // Chart Title (Axis Label)
            ts.yAxisLabel = ts.svg.append("text")
                .attr("class", "chart-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (h / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle");

            // Data Paths & Areas
            ts.launchArea = ts.svg.append("path").attr("class", "launch-area");
            ts.launchLine = ts.svg.append("path").attr("class", "launch-line");
            ts.resaleLine = ts.svg.append("path").attr("class", "resale-line");
            
            ts.sparseLaunchArea = ts.svg.append("path").attr("class", "launch-area sparse-area");
            ts.sparseLaunchLine = ts.svg.append("path").attr("class", "launch-line sparse-line");
            ts.sparseResaleLine = ts.svg.append("path").attr("class", "resale-line sparse-line");

            // Legend
            const legend = ts.svg.append("g")
                .attr("transform", `translate(${w - 300}, ${-margin.top + 5})`);
                
            legend.append("rect")
                .attr("x", 0).attr("y", -5)
                .attr("width", 130).attr("height", 20)
                .attr("fill", d3_colors.iqrLaunch).attr("opacity", 0.3);
            legend.append("line")
                .attr("x1", 0).attr("x2", 10)
                .attr("y1", 5).attr("y2", 5)
                .attr("stroke", d3_colors.launch).attr("stroke-width", 2);
            legend.append("text").text("Launch (Avg + IQR)").attr("x", 15).attr("y", 10).attr("class", "chart-label").attr("font-size", "12px");
            
            legend.append("line")
                .attr("x1", 140).attr("x2", 150)
                .attr("y1", 5).attr("y2", 5)
                .attr("stroke", d3_colors.resale).attr("stroke-width", 2);
            legend.append("text").text("Resale (Avg)").attr("x", 155).attr("y", 10).attr("class", "chart-label").attr("font-size", "12px");

            // Event Annotations Group
            ts.annotations = ts.svg.append("g").attr("class", "annotations");
            
            // Tooltip listener
            ts.focus = ts.svg.append("g").style("display", "none");
            ts.focus.append("line").attr("class", "focus-line").attr("y1", 0).attr("y2", h).attr("stroke", "#9ca3af").attr("stroke-width", 1).attr("stroke-dasharray", "3,3");
            ts.focusLaunch = ts.focus.append("circle").attr("r", 4).attr("fill", d3_colors.launch);
            ts.focusResale = ts.focus.append("circle").attr("r", 4).attr("fill", d3_colors.resale);
            
            ts.svg.append("rect")
                .attr("class", "overlay")
                .attr("width", w)
                .attr("height", h)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mouseover", () => { ts.focus.style("display", null); tooltip.style("display", "block"); })
                .on("mouseout", () => { ts.focus.style("display", "none"); tooltip.style("display", "none"); })
                .on("mousemove", (event) => mousemove(event, ts.processedData));

            function mousemove(event, data) {
                if (!data || data.length === 0) return;
                const [xm, ym] = d3.pointer(event);
                const xDate = ts.x.invert(xm);
                const bisector = d3.bisector(d => d.date).left;
                const i = bisector(data, xDate, 1);
                const d0 = data[i - 1];
                const d1 = data[i];
                if (!d0 || !d1) return;
                const d = (xDate - d0.date > d1.date - xDate) ? d1 : d0;

                ts.focus.attr("transform", `translate(${ts.x(d.date)},0)`);
                if (d.launch_price) ts.focusLaunch.attr("cy", ts.y(d.launch_price)).style("display", null); else ts.focusLaunch.style("display", "none");
                if (d.resale_price) ts.focusResale.attr("cy", ts.y(d.resale_price)).style("display", null); else ts.focusResale.style("display", "none");

                tooltip.style("left", (event.pageX + 15) + "px")
                       .style("top", (event.pageY - 28) + "px");
                       
                let tooltipHtml = `<div class="tooltip-title">${d.date.getFullYear()}</div>`;
                const formatter = (state.valueType === 'index') ? indexFormatter : priceFormatter;
                const unit = (state.valueType === 'index') ? '' : ' ฿';
                
                if (d.launch_price) {
                    tooltipHtml += `
                        <div class="tooltip-item" style="color: ${d3_colors.launch};">
                            <span>Launch (Avg):</span>
                            <strong>${formatter(d.launch_price)}${unit}</strong>
                        </div>
                        <div class="tooltip-item" style="color: ${d3_colors.iqrLaunch};">
                            <span>Launch (IQR):</span>
                            <strong>${formatter(d.launch_p25)} - ${formatter(d.launch_p75)}${unit}</strong>
                        </div>`;
                }
                if (d.resale_price) {
                     tooltipHtml += `
                        <div class="tooltip-item" style="color: ${d3_colors.resale};">
                            <span>Resale (Avg):</span>
                            <strong>${formatter(d.resale_price)}${unit}</strong>
                        </div>`;
                }
                if (d.coverage_flag === 'low') {
                     tooltipHtml += `<div class="text-xs text-yellow-400 mt-2">ข้อมูลมีความครอบคลุมต่ำ</div>`;
                }
                tooltip.html(tooltipHtml);
            }
        }
        
        function updateTimeSeriesChart() {
            const data = prices_yearly.filter(d => d.area_id === state.currentAreaId);
            const area = areas.find(a => a.area_id === state.currentAreaId);
            d3.select("#timeseries-title").text(`${area.area_name} — ราคาเปิดตัว vs. รีเซล (1995–2025)`);
            
            const container = d3.select("#chart-timeseries-container");
            const { width, height } = container.node().getBoundingClientRect();
            const w = width - margin.left - margin.right;
            const h = height - margin.top - margin.bottom;
            
            // 1. Process data based on toggles
            let baseLaunchPrice = 1;
            let baseResalePrice = 1;
            
            if (state.valueType === 'index') {
                const firstData = data.find(d => d.coverage_flag !== 'low'); // Find first reliable data point
                baseLaunchPrice = firstData ? firstData.launch_price_avg : 1;
                baseResalePrice = firstData ? firstData.resale_price_avg : 1;
            }
            
            const processedData = data.map(d => {
                const cpiAdj = (state.priceType === 'real') ? (100 / d.cpi_index) : 1;
                
                return {
                    date: new Date(d.year, 0, 1),
                    launch_price: (d.launch_price_avg * cpiAdj) / baseLaunchPrice * (state.valueType === 'index' ? 100 : 1),
                    launch_p25: (d.launch_price_p25 * cpiAdj) / baseLaunchPrice * (state.valueType === 'index' ? 100 : 1),
                    launch_p75: (d.launch_price_p75 * cpiAdj) / baseLaunchPrice * (state.valueType === 'index' ? 100 : 1),
                    resale_price: (d.resale_price_avg * cpiAdj) / baseResalePrice * (state.valueType === 'index' ? 100 : 1),
                    coverage_flag: d.coverage_flag
                };
            });
            ts.processedData = processedData; // Save for tooltip
            
            const highCoverageData = processedData.filter(d => d.coverage_flag === 'high');
            const lowCoverageData = processedData.filter(d => d.coverage_flag === 'low');
            
            // 2. Update scales
            ts.x.range([0, w]).domain(d3.extent(processedData, d => d.date));
            
            const yMin = d3.min(processedData, d => Math.min(d.launch_p25, d.resale_price));
            const yMax = d3.max(processedData, d => Math.max(d.launch_p75, d.resale_price));
            
            ts.y = (state.scaleType === 'log') 
                ? d3.scaleLog().range([h, 0]).domain([Math.max(1, yMin * 0.9), yMax * 1.1])
                : d3.scaleLinear().range([h, 0]).domain([0, yMax * 1.1]);
            
            ts.svg.select(".overlay").attr("width", w).attr("height", h);
            ts.focus.select(".focus-line").attr("y2", h);
                
            // 3. Update axes
            ts.xAxisGroup.attr("transform", `translate(0,${h})`)
                .transition().duration(300)
                .call(d3.axisBottom(ts.x).ticks(d3.timeYear.every(width > 600 ? 2 : 5)).tickFormat(d3.timeFormat("%Y")));
            
            const yAxis = d3.axisLeft(ts.y)
                .ticks(5)
                .tickFormat(state.valueType === 'index' ? indexFormatter : d3.format("~s"));
                
            ts.yAxisGroup.transition().duration(300).call(yAxis);
            
            // Update Y-Axis Label
            let yLabel = "";
            if (state.valueType === 'index') yLabel = "Index (100 = Base Year)";
            else if (state.priceType === 'real') yLabel = "ราคา (฿/ตร.ม., ปรับค่า CPI)";
            else yLabel = "ราคา (฿/ตร.ม.)";
            ts.yAxisLabel.attr("x", 0 - (h / 2)).text(yLabel);
            
            // Update grid lines
            ts.yGrid
                .call(d3.axisLeft(ts.y).ticks(5).tickSize(-w).tickFormat(""));
                
            // 4. Define generators
            const launchAreaGen = d3.area()
                .x(d => ts.x(d.date))
                .y0(d => ts.y(d.launch_p25))
                .y1(d => ts.y(d.launch_p75));
                
            const launchLineGen = d3.line()
                .x(d => ts.x(d.date))
                .y(d => ts.y(d.launch_price));
                
            const resaleLineGen = d3.line()
                .x(d => ts.x(d.date))
                .y(d => ts.y(d.resale_price))
                .defined(d => d.resale_price > 0);

            // 5. Draw paths (High coverage)
            ts.launchArea
                .datum(highCoverageData)
                .transition().duration(300)
                .attr("d", launchAreaGen)
                .attr("fill", d3_colors.iqrLaunch)
                .attr("opacity", 0.3);
                
            ts.launchLine
                .datum(highCoverageData)
                .transition().duration(300)
                .attr("d", launchLineGen)
                .attr("fill", "none")
                .attr("stroke", d3_colors.launch)
                .attr("stroke-width", 2.5);
                
            ts.resaleLine
                .datum(highCoverageData)
                .transition().duration(300)
                .attr("d", resaleLineGen)
                .attr("fill", "none")
                .attr("stroke", d3_colors.resale)
                .attr("stroke-width", 2.5);
                
            // 6. Draw paths (Low coverage - dashed/faded)
            // We need to connect the high and low coverage parts
            const allLaunchLineGen = launchLineGen.defined(d => d.coverage_flag === 'low');
            const allResaleLineGen = resaleLineGen.defined(d => d.coverage_flag === 'low');
            const allLaunchAreaGen = launchAreaGen.defined(d => d.coverage_flag === 'low');

            ts.sparseLaunchArea
                .datum(processedData)
                .transition().duration(300)
                .attr("d", allLaunchAreaGen)
                .attr("fill", d3_colors.iqrLaunch)
                .attr("class", "launch-area sparse-area"); // style handles opacity

            ts.sparseLaunchLine
                .datum(processedData)
                .transition().duration(300)
                .attr("d", allLaunchLineGen)
                .attr("fill", "none")
                .attr("stroke", d3_colors.launch)
                .attr("stroke-width", 2.5)
                .attr("class", "launch-line sparse-line"); // style handles dash

            ts.sparseResaleLine
                .datum(processedData)
                .attr("stroke", d3_colors.resale).attr("stroke-width", 2.5);
                
            // 7. Draw Annotations
            ts.annotations.selectAll("*").remove();
            
            // Filter events based on active toggles
            const visibleEvents = events.filter(e => state.activeEventTypes.includes(e.type));
            const validEvents = visibleEvents.filter(e => ts.x(new Date(e.year, 0, 1)) > 0 && ts.x(new Date(e.year, 0, 1)) < w);
            
            const eventGroups = ts.annotations.selectAll("g")
                .data(validEvents)
                .join("g")
                .attr("transform", d => `translate(${ts.x(new Date(d.year, 0, 1))}, 0)`);
                
            eventGroups.append("line")
                .attr("y1", 10)
                .attr("y2", h)
                .attr("stroke", d => event_colors[d.type] || "#9ca3af")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .attr("opacity", 0.8);
                
            eventGroups.append("text")
                .attr("y", 10)
                .attr("x", 5)
                .attr("class", "chart-label")
                .attr("font-size", "11px")
                .attr("fill", d => event_colors[d.type] || "#9ca3af")
                .text(d => d.label);
        }

        // --- Chart B1: DOM Scatter ---
        let ds = {}; // DOM Scatter chart object
        function initDOMScatterChart() {
            const container = d3.select("#chart-dom-scatter-container");
            const svg = d3.select("#chart-dom-scatter");
            svg.selectAll("*").remove();
            
            const { width, height } = container.node().getBoundingClientRect();
            ds.w = width - margin.left - margin.right;
            ds.h = height - margin.top - margin.bottom;

            ds.svg = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            
            ds.x = d3.scaleLinear().range([0, ds.w]);
            ds.y = d3.scaleLinear().range([ds.h, 0]);
            
            ds.xAxisGroup = ds.svg.append("g")
                .attr("class", "axis axis-x")
                .attr("transform", `translate(0,${ds.h})`);
            ds.yAxisGroup = ds.svg.append("g")
                .attr("class", "axis axis-y");
                
            ds.svg.append("text")
                .attr("class", "chart-label")
                .attr("transform", `translate(${ds.w / 2}, ${ds.h + margin.bottom - 10})`)
                .style("text-anchor", "middle")
                .text("จำนวนวันที่ประกาศ (DOM)");
                
            ds.svg.append("text")
                .attr("class", "chart-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (ds.h / 2))
                .style("text-anchor", "middle")
                .text("ราคา (฿/ตร.ม.)");
                
            ds.clip = ds.svg.append("defs").append("clipPath")
                .attr("id", "clip-scatter")
                .append("rect")
                .attr("width", ds.w)
                .attr("height", ds.h);
                
            ds.scatterArea = ds.svg.append("g")
                .attr("clip-path", "url(#clip-scatter)");
                
            ds.medianXLine = ds.scatterArea.append("line").attr("class", "median-line");
            ds.medianYLine = ds.scatterArea.append("line").attr("class", "median-line");
            ds.medianXLabel = ds.svg.append("text").attr("class", "median-label");
            ds.medianYLabel = ds.svg.append("text").attr("class", "median-label");
        }

        function updateDOMScatterChart() {
            const data = listings.filter(d => d.area_id === state.currentAreaId);
            const area = areas.find(a => a.area_id === state.currentAreaId);
            d3.select("#dom-scatter-title").text(`DOM vs. Price: ${area.area_name}`);
            
            ds.x.domain([0, d3.max(data, d => d.dom_days) * 1.05]);
            ds.y.domain([0, d3.max(data, d => d.price_sqm) * 1.05]);
            
            ds.xAxisGroup.transition().duration(300).call(d3.axisBottom(ds.x).ticks(5).tickFormat(d3.format("~s")));
            ds.yAxisGroup.transition().duration(300).call(d3.axisLeft(ds.y).ticks(5).tickFormat(d3.format("~s")));
            
            // Median lines
            const medianDOM = d3.median(data, d => d.dom_days);
            const medianPrice = d3.median(data, d => d.price_sqm);
            
            ds.medianXLine
                .transition().duration(300)
                .attr("x1", ds.x(medianDOM))
                .attr("x2", ds.x(medianDOM))
                .attr("y1", 0)
                .attr("y2", ds.h);
                
            ds.medianYLine
                .transition().duration(300)
                .attr("x1", 0)
                .attr("x2", ds.w)
                .attr("y1", ds.y(medianPrice))
                .attr("y2", ds.y(medianPrice));

            ds.medianXLabel
                .attr("x", ds.x(medianDOM) + 4)
                .attr("y", margin.top - 20)
                .text(`Median DOM: ${domFormatter(medianDOM)}`);
            ds.medianYLabel
                .attr("x", 4)
                .attr("y", ds.y(medianPrice) - 4)
                .text(`Median Price: ${priceFormatter(medianPrice)}`);

            // Points
            ds.scatterArea.selectAll("circle")
                .data(data, d => d.listing_id)
                .join(
                    enter => enter.append("circle")
                        .attr("cx", d => ds.x(d.dom_days))
                        .attr("cy", d => ds.y(d.price_sqm))
                        .attr("r", 3)
                        .attr("fill", d3_colors.launch)
                        .attr("opacity", 0)
                        .call(enter => enter.transition().duration(500).attr("opacity", 0.4)),
                    update => update
                        .transition().duration(300)
                        .attr("cx", d => ds.x(d.dom_days))
                        .attr("cy", d => ds.y(d.price_sqm)),
                    exit => exit
                        .transition().duration(300)
                        .attr("r", 0)
                        .remove()
                )
                .on("mouseover", (event, d) => {
                    tooltip.style("display", "block")
                           .html(`
                                <div class="tooltip-title">${d.project}</div>
                                <div class="tooltip-item"><span>Price/sqm:</span> <strong>${priceFormatter(d.price_sqm)} ฿</strong></div>
                                <div class="tooltip-item"><span>DOM:</span> <strong>${domFormatter(d.dom_days)} วัน</strong></div>
                                <div class="tooltip-item"><span>Size:</span> <strong>${d.size_sqm.toFixed(1)} ตร.ม.</strong></div>
                                <div class="tooltip-item"><span>Plan:</span> <strong>${d.plan_type}</strong></div>
                           `);
                })
                .on("mousemove", (event) => {
                    tooltip.style("left", (event.pageX + 15) + "px")
                           .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.style("display", "none");
                });
        }

        // --- Chart B2: DOM Distribution (Boxplot) ---
        let db = {}; // DOM Boxplot chart object
        function initDOMBoxplotChart() {
            const container = d3.select("#chart-dom-dist-container");
            const svg = d3.select("#chart-dom-dist");
            svg.selectAll("*").remove();
            
            const { width, height } = container.node().getBoundingClientRect();
            db.w = width - margin.left - margin.right;
            db.h = height - margin.top - margin.bottom;

            db.svg = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            
            db.x = d3.scaleBand().range([0, db.w]).paddingInner(0.1).paddingOuter(0.05);
            db.y = d3.scaleLinear().range([db.h, 0]);
            
            db.xAxisGroup = db.svg.append("g")
                .attr("class", "axis axis-x")
                .attr("transform", `translate(0,${db.h})`);
            db.yAxisGroup = db.svg.append("g")
                .attr("class", "axis axis-y");
                
            db.svg.append("text")
                .attr("class", "chart-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (db.h / 2))
                .style("text-anchor", "middle")
                .text("จำนวนวันที่ประกาศ (DOM)");
                
            db.boxGroup = db.svg.append("g").attr("class", "box-group");
        }

        function updateDOMBoxplotChart() {
            const data = dom_stats.filter(d => d.area_id === state.currentAreaId);
            const area = areas.find(a => a.area_id === state.currentAreaId);
            d3.select("#dom-dist-title").text(`DOM Distribution: ${area.area_name}`);
            
            db.x.domain(data.map(d => d.year_bucket));
            db.y.domain([0, d3.max(data, d => d.dom_p75) * 1.05]);
            
            db.xAxisGroup.transition().duration(300).call(d3.axisBottom(db.x));
            db.yAxisGroup.transition().duration(300).call(d3.axisLeft(db.y).ticks(5).tickFormat(domFormatter));
            
            const boxWidth = db.x.bandwidth() * 0.6;
            
            db.boxGroup.selectAll("g.box")
                .data(data, d => d.year_bucket)
                .join(
                    enter => {
                        const g = enter.append("g").attr("class", "box");
                        
                        // Main IQR Box
                        g.append("rect")
                            .attr("x", d => db.x(d.year_bucket) + (db.x.bandwidth() - boxWidth) / 2)
                            .attr("y", d => db.y(d.dom_p75))
                            .attr("width", boxWidth)
                            .attr("height", d => db.y(d.dom_p25) - db.y(d.dom_p75))
                            .attr("fill", d3_colors.resale)
                            .attr("opacity", 0.6)
                            .attr("stroke", d3_colors.resale)
                            .attr("stroke-width", 1);
                            
                        // Median line
                        g.append("line")
                            .attr("x1", d => db.x(d.year_bucket) + (db.x.bandwidth() - boxWidth) / 2)
                            .attr("x2", d => db.x(d.year_bucket) + (db.x.bandwidth() + boxWidth) / 2)
                            .attr("y1", d => db.y(d.dom_median))
                            .attr("y2", d => db.y(d.dom_median))
                            .attr("stroke", "#ffffff")
                            .attr("stroke-width", 2);
                            
                        // Tooltip rectangle
                        g.append("rect")
                            .attr("x", d => db.x(d.year_bucket))
                            .attr("y", 0)
                            .attr("width", db.x.bandwidth())
                            .attr("height", db.h)
                            .attr("fill", "transparent")
                            .on("mouseover", (event, d) => {
                                tooltip.style("display", "block")
                                    .html(`
                                        <div class="tooltip-title">${d.year_bucket}</div>
                                        <div class="tooltip-item"><span>Median:</span> <strong>${domFormatter(d.dom_median)} วัน</strong></div>
                                        <div class="tooltip-item"><span>IQR (P25-P75):</span> <strong>${domFormatter(d.dom_p25)} - ${domFormatter(d.dom_p75)}</strong></div>
                                        <div class="tooltip-item"><span>N Listings:</span> <strong>${d.n_listings.toFixed(0)}</strong></div>
                                    `);
                            })
                            .on("mousemove", (event) => {
                                tooltip.style("left", (event.pageX + 15) + "px")
                                    .style("top", (event.pageY - 28) + "px");
                            })
                            .on("mouseout", () => {
                                tooltip.style("display", "none");
                            });
                            
                        return g;
                    },
                    update => {
                        update.select("rect.box-rect")
                            .transition().duration(300)
                            .attr("y", d => db.y(d.dom_p75))
                            .attr("height", d => db.y(d.dom_p25) - db.y(d.dom_p75));
                            
                        update.select("line.median-line")
                            .transition().duration(300)
                            .attr("y1", d => db.y(d.dom_median))
                            .attr("y2", d => db.y(d.dom_median));
                            
                        return update;
                    },
                    exit => exit.remove()
                );
        }

        // --- Chart C: Mini-Multiples ---
        function updateMiniMultiples() {
            const container = d3.select("#chart-multiples");
            container.selectAll("*").remove(); // Clear
            
            const miniMargin = { top: 20, right: 10, bottom: 20, left: 10 };
            const { width } = container.node().getBoundingClientRect();
            const chartWidth = (width / (areas.length > 2 ? 4 : 2)) - 16; // 16 is gap
            const chartHeight = 120;
            
            const w = chartWidth - miniMargin.left - miniMargin.right;
            const h = chartHeight - miniMargin.top - miniMargin.bottom;
            
            const allProcessed = [];
            areas.forEach(area => {
                const data = prices_yearly.filter(d => d.area_id === area.area_id);
                const firstData = data.find(d => d.coverage_flag !== 'low');
                const baseLaunchPrice = firstData ? firstData.launch_price_avg : 1;
                
                data.forEach(d => {
                    allProcessed.push({
                        area_id: d.area_id,
                        date: new Date(d.year, 0, 1),
                        index: (d.launch_price_avg / baseLaunchPrice) * 100
                    });
                });
            });
            
            const x = d3.scaleTime()
                .domain(d3.extent(allProcessed, d => d.date))
                .range([0, w]);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(allProcessed, d => d.index) * 1.05])
                .range([h, 0]);
                
            const lineGen = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.index));
                
            const areaGroups = container.selectAll("div")
                .data(areas)
                .join("div")
                .attr("class", "bg-gray-700 p-2 rounded-md");
                
            areaGroups.append("h4")
                .attr("class", "text-sm font-medium text-white text-center")
                .text(d => d.area_name);
                
            const svgs = areaGroups.append("svg")
                .attr("width", chartWidth)
                .attr("height", chartHeight)
                .append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);
                
            svgs.append("path")
                .datum(d => allProcessed.filter(p => p.area_id === d.area_id))
                .attr("d", lineGen)
                .attr("fill", "none")
                .attr("stroke", d3_colors.launch)
                .attr("stroke-width", 2);
                
            // Add minimal axes
            svgs.append("g")
                .attr("transform", `translate(0,${h})`)
                .call(d3.axisBottom(x).ticks(2).tickFormat(d3.timeFormat("%Y")))
                .attr("class", "axis");
        }
        
        // --- Chart D: Plan Types Teaser (Stacked Area) ---
        let pt = {}; // Plan Types chart object
        function initPlanTypesChart() {
            const container = d3.select("#chart-plan-types-container");
            const svg = d3.select("#chart-plan-types");
            svg.selectAll("*").remove();
            
            const { width, height } = container.node().getBoundingClientRect();
            pt.w = width - margin.left - margin.right;
            pt.h = height - margin.top - margin.bottom;

            pt.svg = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            
            pt.x = d3.scaleTime().range([0, pt.w]);
            pt.y = d3.scaleLinear().range([pt.h, 0]);
            pt.color = d3.scaleOrdinal()
                .domain(['1Bed', '1Bed+', '2Bed', 'Lite'])
                .range(['#0d9488', '#059669', '#1d4ed8', '#6d28d9']); // teal, green, blue, violet
            
            pt.xAxisGroup = pt.svg.append("g")
                .attr("class", "axis axis-x")
                .attr("transform", `translate(0,${pt.h})`);
            pt.yAxisGroup = pt.svg.append("g")
                .attr("class", "axis axis-y");
                
            pt.yAxisLabel = pt.svg.append("text")
                .attr("class", "chart-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (pt.h / 2))
                .style("text-anchor", "middle")
                .text("สัดส่วนยูนิต");
                
            pt.stackGroup = pt.svg.append("g").attr("class", "stack-group");
            
            // Legend
            const legend = pt.svg.append("g")
                .attr("transform", `translate(0, ${-margin.top + 5})`);
            
            pt.color.domain().forEach((d, i) => {
                const legendItem = legend.append("g").attr("transform", `translate(${i * 80}, 0)`);
                legendItem.append("rect")
                    .attr("width", 12).attr("height", 12)
                    .attr("fill", pt.color(d)).attr("rx", 2);
                legendItem.append("text")
                    .attr("x", 16).attr("y", 10)
                    .text(d).attr("class", "chart-label");
            });
        }
        
        function updatePlanTypesChart() {
            const data = plan_types_data;
            const keys = pt.color.domain();
            
            const stack = d3.stack()
                .keys(keys)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetExpand); // This makes it a 100% stacked area
                
            const series = stack(data);
            
            pt.x.domain(d3.extent(data, d => d.year));
            pt.y.domain([0, 1]); // 0 to 100%
            
            pt.xAxisGroup.transition().duration(300)
                .call(d3.axisBottom(pt.x).ticks(d3.timeYear.every(pt.w > 600 ? 2 : 5)).tickFormat(d3.timeFormat("%Y")));
            pt.yAxisGroup.transition().duration(300)
                .call(d3.axisLeft(pt.y).ticks(5).tickFormat(d3.format(".0%")));
                
            const areaGen = d3.area()
                .x(d => pt.x(d.data.year))
                .y0(d => pt.y(d[0]))
                .y1(d => pt.y(d[1]));
                
            pt.stackGroup.selectAll("path")
                .data(series)
                .join(
                    enter => enter.append("path")
                        .attr("fill", d => pt.color(d.key))
                        .attr("d", areaGen)
                        .attr("opacity", 0)
                        .call(enter => enter.transition().duration(500).attr("opacity", 0.8)),
                    update => update
                        .transition().duration(300)
                        .attr("d", areaGen)
                        .attr("fill", d => pt.color(d.key)),
                    exit => exit.remove()
                )
                .on("mouseover", (event, d) => {
                    d3.select(event.currentTarget).attr("opacity", 1);
                    tooltip.style("display", "block")
                           .html(`<div class="tooltip-title" style="color: ${pt.color(d.key)}">${d.key}</div>`);
                })
                .on("mousemove", (event) => {
                    tooltip.style("left", (event.pageX + 15) + "px")
                           .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", (event) => {
                    d3.select(event.currentTarget).attr("opacity", 0.8);
                    tooltip.style("display", "none");
                });
        }


        // === 4. MODAL & AI FUNCTIONS ===
        const modal = d3.select("#gemini-modal");
        
        function showLoadingModal(title) {
            modal.select("#gemini-modal-title").text(title);
            modal.select("#gemini-modal-loading").classed("hidden", false);
            modal.select("#gemini-modal-result").classed("hidden", true);
            modal.classed("hidden", false);
        }
        
        function showGeminiResult(title, content) {
            modal.select("#gemini-modal-title").text(title);
            modal.select("#gemini-modal-text").text(content); // Use .text() to prevent HTML injection
            modal.select("#gemini-modal-loading").classed("hidden", true);
            modal.select("#gemini-modal-result").classed("hidden", false);
        }
        
        function hideModal() {
            modal.classed("hidden", true);
        }
        
        async function handleTimeSeriesSummary() {
            const area = areas.find(a => a.area_id === state.currentAreaId);
            if (!ts.processedData) return;
            
            // Slice data to keep prompt reasonable
            const dataSummary = ts.processedData.slice(-15).map(d => ({
                year: d.date.getFullYear(),
                launch_avg: d.launch_price,
                launch_iqr: [d.launch_p25, d.launch_p75],
                resale_avg: d.resale_price,
                coverage: d.coverage_flag
            }));
            
            const systemPrompt = `คุณคือนักวิเคราะห์ข้อมูลอสังหาริมทรัพย์ สไตล์ Bloomberg ที่เป็นกลางและเน้นข้อเท็จจริง
คุณจะได้รับข้อมูล JSON Time-series ของราคาคอนโดในพื้นที่หนึ่ง
หน้าที่ของคุณคือสรุป "ข้อเท็จจริง" (facts) ที่น่าสนใจจากข้อมูลนี้เป็น "ภาษาไทย" ในรูปแบบ bullet points
- ห้ามใช้คำชี้นำ เช่น "ดี", "แย่", "ถูก", "แพง", "น่าสนใจ", "ควรซื้อ"
- ให้เน้นแนวโน้ม (trends), ความผันผวน (volatility/IQR), และจุดเปลี่ยนแปลงที่เห็นได้ชัด
- สรุปให้กระชับ ไม่เกิน 4-5 bullet points
- ตัวอย่าง: "ราคาเปิดตัวเฉลี่ยในปี 2024 อยู่ที่ ${priceFormatter(dataSummary.slice(-1)[0].launch_avg)} ฿" หรือ "ช่วงราคา IQR ของราคาเปิดตัวกว้างขึ้นจากปี 2020 ถึง 2024"`;
            
            const userPrompt = `นี่คือข้อมูลราคาสำหรับพื้นที่ ${area.area_name} (สถานะ: ${state.priceType}, ${state.valueType}, ${state.scaleType}) ในช่วง 15 ปีล่าสุด:
${JSON.stringify(dataSummary)}`;
            
            showLoadingModal("✨ กำลังสรุปข้อมูล Time-Series...");
            
            try {
                const result = await callGeminiAPI(systemPrompt, userPrompt);
                // Simple markdown-like formatting for bullets
                const formattedResult = result.text.replace(/•/g, "\n•");
                showGeminiResult(`✨ สรุปข้อมูล: ${area.area_name}`, formattedResult);
            } catch (error) {
                console.error("Gemini API Error:", error);
                showGeminiResult("เกิดข้อผิดพลาด", `ไม่สามารถเรียกข้อมูล AI ได้: ${error.message}`);
            }
        }
        
        async function handleDOMScatterSummary() {
            const area = areas.find(a => a.area_id === state.currentAreaId);
            const data = listings.filter(d => d.area_id === state.currentAreaId);
            if (data.length === 0) return;

            // Slice data and select key fields
            const dataSummary = data.slice(0, 100).map(d => ({
                price_sqm: d.price_sqm,
                dom_days: d.dom_days
            }));
            
            const medianDOM = d3.median(data, d => d.dom_days);
            const medianPrice = d3.median(data, d => d.price_sqm);

            const systemPrompt = `คุณคือนักวิเคราะห์ข้อมูลอสังหาริมทรัพย์ สไตล์ Bloomberg ที่เป็นกลางและเน้นข้อเท็จจริง
คุณจะได้รับข้อมูล JSON listings 100 รายการ ที่มี 'price_sqm' (ราคาต่อ ตร.ม.) และ 'dom_days' (วันที่อยู่ในตลาด)
หน้าที่ของคุณคือสรุป "ข้อเท็จจริง" (facts) เกี่ยวกับการกระจายตัวและความสัมพันธ์ของข้อมูลนี้เป็น "ภาษาไทย" ในรูปแบบ bullet points
- ห้ามใช้คำชี้นำ หรือให้คำแนะนำการลงทุน
- ให้เน้นการกระจายตัว (distribution) และความสัมพันธ์ (correlation)
- สรุปให้กระชับ ไม่เกิน 3-4 bullet points
- ข้อมูล Median DOM คือ ${domFormatter(medianDOM)} วัน และ Median Price คือ ${priceFormatter(medianPrice)} ฿
- ตัวอย่าง: "ยูนิตส่วนใหญ่ (X%) กระจุกตัวอยู่ที่ช่วงราคา A-B ฿ และใช้เวลาขาย C-D วัน" หรือ "ไม่พบความสัมพันธ์ที่ชัดเจนระหว่างราคาและ DOM ในชุดข้อมูลนี้"`;
                
            const userPrompt = `นี่คือข้อมูล 100 listings แรกสำหรับพื้นที่ ${area.area_name}:
${JSON.stringify(dataSummary)}`;

            showLoadingModal("✨ กำลังวิเคราะห์ DOM Scatter Plot...");

            try {
                const result = await callGeminiAPI(systemPrompt, userPrompt);
                const formattedResult = result.text.replace(/•/g, "\n•");
                showGeminiResult(`✨ วิเคราะห์ DOM: ${area.area_name}`, formattedResult);
            } catch (error) {
                console.error("Gemini API Error:", error);
                showGeminiResult("เกิดข้อผิดพลาด", `ไม่สามารถเรียกข้อมูล AI ได้: ${error.message}`);
            }
        }

        // === 5. INITIALIZATION & EVENT LISTENERS ===
        
        function updateAllCharts() {
            updateTimeSeriesChart();
            updateDOMScatterChart();
            updateDOMBoxplotChart();
            updateMiniMultiples();
            updatePlanTypesChart(); // This one is not area-dependent, but redraws on resize
        }
        
        function initControls() {
            // Populate Area Selector
            const areaSelect = d3.select("#area-select");
            areaSelect.selectAll("option")
                .data(areas)
                .join("option")
                .attr("value", d => d.area_id)
                .text(d => d.area_name);
                
            areaSelect.on("change", (event) => {
                state.currentAreaId = event.target.value;
                updateTimeSeriesChart();
                updateDOMScatterChart();
                updateDOMBoxplotChart();
                // Mini-multiples and Plan types don't need area update
            });
            
            // Price Type Toggle
            d3.select("#price-type-toggle").selectAll("button")
                .on("click", function() {
                    d3.select("#price-type-toggle").selectAll("button").classed("active", false);
                    d3.select(this).classed("active", true);
                    state.priceType = d3.select(this).attr("data-value");
                    updateTimeSeriesChart();
                });
                
            // Value Type Toggle
            d3.select("#value-type-toggle").selectAll("button")
                .on("click", function() {
                    d3.select("#value-type-toggle").selectAll("button").classed("active", false);
                    d3.select(this).classed("active", true);
                    state.valueType = d3.select(this).attr("data-value");
                    updateTimeSeriesChart();
                });

            // Scale Type Toggle
            d3.select("#scale-type-toggle").selectAll("button")
                .on("click", function() {
                    d3.select("#scale-type-toggle").selectAll("button").classed("active", false);
                    d3.select(this).classed("active", true);
                    state.scaleType = d3.select(this).attr("data-value");
                    updateTimeSeriesChart();
                });
                
            // New AI Button Listeners
            d3.select("#btn-ai-timeseries").on("click", handleTimeSeriesSummary);
            d3.select("#btn-ai-domscatter").on("click", handleDOMScatterSummary);
            
            // New Event Toggle Listeners
            const eventToggles = [
                { type: 'transit', label: '🚇 Transit' },
                { type: 'policy', label: '📜 Policy' },
                { type: 'plan', label: '🏗️ City Plan' },
                { type: 'landmark', label: '🚩 Landmark' }
            ];
            
            d3.select("#event-toggles").selectAll("button")
                .data(eventToggles)
                .join("button")
                .attr("class", "event-toggle-btn")
                .attr("data-type", d => d.type)
                .style("border-color", d => event_colors[d.type])
                .classed("active", d => state.activeEventTypes.includes(d.type))
                .style("background-color", d => state.activeEventTypes.includes(d.type) ? event_colors[d.type] : '#374151')
                .html(d => d.label)
                .on("click", function(event, d) {
                    const btn = d3.select(this);
                    const type = d.type;
                    const isActive = state.activeEventTypes.includes(type);
                    
                    if (isActive) {
                        state.activeEventTypes = state.activeEventTypes.filter(t => t !== type);
                        btn.classed("active", false).style("background-color", '#374151');
                    } else {
                        state.activeEventTypes.push(type);
                        btn.classed("active", true).style("background-color", event_colors[type]);
                    }
                    
                    updateTimeSeriesChart(); // Redraw annotations
                });
        }
        
        // --- Debounce for resize ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- Initial Load ---
        function initializeDashboard() {
            initControls();
            
            // Init all chart containers
            initTimeSeriesChart();
            initDOMScatterChart();
            initDOMBoxplotChart();
            initPlanTypesChart();
            
            // First render
            updateAllCharts();
            
            // Add resize listener
            window.addEventListener("resize", debounce(updateAllCharts, 200));
            
            // Add modal close listeners
            d3.select("#gemini-modal-close").on("click", hideModal);
            d3.select("#gemini-modal-close-btn").on("click", hideModal);
        }
        
        initializeDashboard();

    </script>
</body>
</html>



